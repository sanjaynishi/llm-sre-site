// ui/src/pages/Mcp.jsx
import React, { useMemo, useRef, useState } from "react";
import { apiPost } from "../api/client";
import { MCP_SCENARIOS } from "../data/mcpScenarios";

function pretty(obj) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch {
    return String(obj);
  }
}

function looksLikeHtml(contentType, text) {
  const ct = String(contentType || "").toLowerCase();
  const t = String(text || "").trimStart().toLowerCase();
  return (
    ct.includes("text/html") ||
    t.startsWith("<!doctype html") ||
    t.startsWith("<html") ||
    t.includes("<title>error") ||
    t.includes("generated by cloudfront")
  );
}

/**
 * MCP soft retry wrapper:
 * - Tries normal apiPost first (your existing client)
 * - If it throws a known "HTML/504/CloudFront" type failure, retries once
 * - Provides UI-friendly status updates
 */
async function postMcpWithSoftRetry(
  payload,
  {
    retryDelayMs = 900,
    onStatus = () => {},
    // fallback-only fetch retry if apiPost throws
    retryOnStatuses = [502, 503, 504],
  } = {}
) {
  // Attempt #1 using your existing client
  try {
    onStatus("Running…");
    const res = await apiPost("/api/mcp/run", payload);
    return { ok: true, data: res, meta: { retried: false, via: "apiPost" } };
  } catch (e1) {
    const msg1 = String(e1?.message || e1 || "");
    const shouldRetry =
      retryOnStatuses.some((s) => msg1.includes(`HTTP ${s}`)) ||
      msg1.toLowerCase().includes("text/html") ||
      msg1.toLowerCase().includes("cloudfront") ||
      msg1.toLowerCase().includes("<!doctype html") ||
      msg1.toLowerCase().includes("<html") ||
      msg1.toLowerCase().includes("gateway timeout") ||
      msg1.toLowerCase().includes("timed out");

    if (!shouldRetry) {
      throw e1;
    }

    onStatus("First call hit a CloudFront/HTML error — retrying once…");
    await new Promise((r) => setTimeout(r, retryDelayMs));

    // Attempt #2 — use fetch directly so we can detect HTML and show a better error
    const res2 = await fetch("/api/mcp/run", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json" },
      body: JSON.stringify(payload ?? {}),
    });

    const text2 = await res2.text();
    const ct2 = res2.headers.get("content-type") || "";

    // Try JSON parse
    let json2 = null;
    try {
      json2 = JSON.parse(text2);
    } catch {
      json2 = null;
    }

    if (res2.ok && json2) {
      return {
        ok: true,
        data: json2,
        meta: { retried: true, via: "fetch", firstError: msg1 },
      };
    }

    // Still failing — build a clear error that matches what you saw in UI
    const htmlish = looksLikeHtml(ct2, text2);
    const errMsg = htmlish
      ? `Expected JSON but got "text/html". This usually means CloudFront/Origin returned an HTML error page (cold start/timeout). (HTTP ${res2.status})`
      : `Request failed (HTTP ${res2.status}).`;

    const preview = String(text2 || "").slice(0, 800);

    const err = new Error(
      `${errMsg}\nFirst error: ${msg1}\n(First 800 chars): ${preview}`
    );
    throw err;
  }
}

export default function Mcp() {
  const baseUrl = useMemo(() => window.location.origin, []);
  const resultsRef = useRef(null);

  const [active, setActive] = useState(null);
  const [running, setRunning] = useState(false);
  const [result, setResult] = useState(null);
  const [error, setError] = useState("");
  const [banner, setBanner] = useState("");
  const [statusLine, setStatusLine] = useState(""); // shows “retrying…” etc.

  function scrollToResults() {
    setTimeout(() => {
      resultsRef.current?.scrollIntoView({ behavior: "smooth", block: "start" });
    }, 50);
  }

  async function runScenario(s) {
    setActive(s.key);
    setRunning(true);
    setError("");
    setResult(null);
    setBanner("");
    setStatusLine("");

    try {
      const payload = s.request(baseUrl);

      const out = await postMcpWithSoftRetry(payload, {
        retryDelayMs: 900,
        onStatus: (t) => setStatusLine(t),
      });

      setResult(out.data);

      if (out?.meta?.retried) {
        setBanner("✅ MCP finished — retry succeeded. Results are below (auto-scrolled).");
      } else {
        setBanner("✅ MCP finished — results are below (auto-scrolled).");
      }

      scrollToResults();
    } catch (e) {
      setError(String(e?.message || e));
      setBanner("");
      scrollToResults();
    } finally {
      setRunning(false);
      setStatusLine("");
    }
  }

  const plannerModel = result?.llm?.planner_model || result?.model || "unknown";
  const reasonModel = result?.llm?.reasoning_model || result?.model || "unknown";
  const provider = result?.llm?.provider || (result?.model ? "openai" : "—");
  const temp =
    typeof result?.llm?.temperature === "number" ? result.llm.temperature : null;

  return (
    <div>
      <h2 style={{ marginTop: 0 }}>MCP — Agentic Orchestration</h2>
      <p style={{ marginTop: 6, opacity: 0.9 }}>
        These scenarios demonstrate{" "}
        <b>plan → tool use → observation → retry → reasoning</b>, with
        step-by-step visibility.
      </p>

      {MCP_SCENARIOS.map((s) => (
        <div key={s.key} style={card}>
          <h3 style={{ margin: "0 0 6px" }}>{s.title}</h3>
          <p style={{ margin: "0 0 10px", opacity: 0.9 }}>{s.description}</p>

          <details>
            <summary>
              <b>Question</b>
            </summary>
            <p style={{ marginTop: 8 }}>{s.question}</p>
          </details>

          <details style={{ marginTop: 8 }}>
            <summary>
              <b>Expected steps</b>
            </summary>
            <ul style={{ marginTop: 8 }}>
              {s.expectedSteps.map((x, i) => (
                <li key={i}>{x}</li>
              ))}
            </ul>
          </details>

          <div style={{ marginTop: 10, display: "flex", gap: 10, alignItems: "center" }}>
            <button
              onClick={() => runScenario(s)}
              disabled={running}
              style={{
                ...button,
                opacity: running ? 0.7 : 1,
                cursor: running ? "not-allowed" : "pointer",
              }}
              type="button"
            >
              {running && active === s.key ? "Running…" : "Execute MCP"}
            </button>

            {running && active === s.key && statusLine ? (
              <span style={{ fontWeight: 800, opacity: 0.85 }}>{statusLine}</span>
            ) : null}
          </div>
        </div>
      ))}

      {/* Anchor for auto-scroll */}
      <div ref={resultsRef} />

      {(banner || error || result) && (
        <div style={{ marginTop: 18 }}>
          {banner && <div style={bannerStyle}>{banner}</div>}

          {result && (
            <div style={metaBox}>
              <div style={{ fontWeight: 900, marginBottom: 6 }}>Run metadata</div>

              <div style={metaRow}>
                <span style={metaKey}>Scenario:</span>
                <span style={metaVal}>{result.scenario || "—"}</span>
              </div>
              <div style={metaRow}>
                <span style={metaKey}>Run ID:</span>
                <span style={metaVal}>{result.run_id || "—"}</span>
              </div>
              <div style={metaRow}>
                <span style={metaKey}>LLM provider:</span>
                <span style={metaVal}>{provider}</span>
              </div>
              <div style={metaRow}>
                <span style={metaKey}>Planner model:</span>
                <span style={metaVal}>{plannerModel}</span>
              </div>
              <div style={metaRow}>
                <span style={metaKey}>Reasoner model:</span>
                <span style={metaVal}>{reasonModel}</span>
              </div>
              <div style={metaRow}>
                <span style={metaKey}>Temperature:</span>
                <span style={metaVal}>{temp === null ? "—" : String(temp)}</span>
              </div>
            </div>
          )}

          {error && <pre style={errorBox}>{error}</pre>}

          {result && (
            <>
              <div style={{ marginTop: 10, display: "flex", gap: 10 }}>
                <button
                  type="button"
                  onClick={() => {
                    navigator.clipboard
                      ?.writeText(pretty(result))
                      .then(() => setBanner("✅ Copied results JSON to clipboard."))
                      .catch(() =>
                        setBanner("⚠️ Could not copy automatically. Please copy manually.")
                      );
                  }}
                  style={copyBtn}
                >
                  Copy results JSON
                </button>

                <button type="button" onClick={scrollToResults} style={copyBtn}>
                  Scroll to results
                </button>
              </div>

              <pre style={output}>{pretty(result)}</pre>
            </>
          )}
        </div>
      )}
    </div>
  );
}

const card = {
  marginTop: 16,
  padding: 14,
  background: "#ffffff",
  border: "1px solid #e5e7eb",
  borderRadius: 14,
};

const button = {
  padding: "8px 14px",
  fontWeight: 900,
  borderRadius: 10,
  border: "1px solid #1d4ed8",
  background: "#2563eb",
  color: "#fff",
};

const bannerStyle = {
  marginTop: 10,
  padding: "10px 12px",
  borderRadius: 12,
  background: "#ecfdf5",
  border: "1px solid #a7f3d0",
  color: "#065f46",
  fontWeight: 800,
};

const metaBox = {
  marginTop: 12,
  padding: 12,
  borderRadius: 14,
  background: "#ffffff",
  border: "1px solid #e5e7eb",
};

const metaRow = {
  display: "flex",
  gap: 10,
  alignItems: "baseline",
  marginTop: 6,
};

const metaKey = {
  width: 140,
  fontWeight: 800,
  color: "#374151",
};

const metaVal = {
  color: "#111827",
  fontFamily:
    '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Arial, sans-serif',
};

const copyBtn = {
  padding: "8px 12px",
  fontWeight: 900,
  borderRadius: 10,
  border: "1px solid #d1d5db",
  background: "#ffffff",
  cursor: "pointer",
};

const output = {
  marginTop: 12,
  padding: 12,
  background: "#0f172a",
  color: "#e5e7eb",
  borderRadius: 10,
  maxHeight: 520,
  overflow: "auto",
  fontSize: 12,
};

const errorBox = {
  marginTop: 12,
  padding: 12,
  background: "#fee2e2",
  color: "#7f1d1d",
  borderRadius: 10,
};